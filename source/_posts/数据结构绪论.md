---
title: 数据结构绪论
author: Yancey
top: false
cover: false
toc: true
img: 'https://yancey597.github.io/posts/27273/sjjg.jpg'
summary: 数据结构绪论知识
tags: 数据结构
categories: 笔记
abbrlink: b06cc6ec
date: 2021-11-15 19:37:24
password:
---

> Yancey 408 数据结构学习笔记



# 一、绪论

### 1.0 导学思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/1.jpg" ></img>

**数据结构学什么：**

<aside> 💡 **程序代码把现实世界中的问题信息化 如何用计算机高效的处理这些信息创造价值**</aside>

<img src="https://yancey597.github.io/posts/b06cc6ec/2.jpg" ></img>

> **信息化时代，四大件学习的重要性**

## 1. 数据结构的基本概念

### 1.1 数据的概念

<aside> 💡 **数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别(二进制0和1)和处理的符号的集合。数据是计算机程序加工的原料。**

</aside>

<img src="https://yancey597.github.io/posts/27273/sjysj.jpg" ></img>

> **数据——用来描述客观现实。**

### 1.2 数据元素、数据项、数据对象的概念

> **早期的计算机主要研究数值型的问题：初代计算机大多被用来科学计算。 现代计算机主要用来研究非数值的问题：个体的具体信息、个体间相互关系。**

<aside> 💡 **数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 具有相同性质的数据元素的集合称为数据对象**

</aside>

> **数据元素———描述一个个体 数据项———数据元素的具体属性 数据对象———相同性质数据元素的集合 数据结构———相互之间存在一种或多种特定关系的数据元素集合**

> **一个班级的每个同学都是一个数据元素，这时候整个班级就可以看做一个数据对象。而数据结构想要研究的是他们之间存在的特定关系。**

<img src="https://yancey597.github.io/posts/b06cc6ec/3.jpg" ></img>

> **数据结构和数据对象的区别：是否关注数据元素间的关系。**

<img src="https://yancey597.github.io/posts/b06cc6ec/4.jpg" ></img>

**相同的数据结构可以构成不同的数据结构，不同的数据元素可以构成相同的数据结构。**

<img src="https://yancey597.github.io/posts/b06cc6ec/5.jpg" ></img>

**数据结构着重关注数据元素的关系、以及操作这些数据元素，不关心具体的数据项内容。**

## 2. 数据结构三要素

### 2.0 导学思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/6.jpg" ></img>

### 2.1 逻辑结构

> **具体构成什么逻辑结构，看我们研究的内容是什么。**

<aside> 💡 **集合：各个元素同属一个集合，不研究其他关系。

线性结构：数据元素间是一对一的关系，除了第一个元素都有唯一前驱，除了最后一个元素都有唯一后继。

树形结构：数据元素间是一对多的关系。

图状结构：数据元素间是多对多的关系。**

</aside>



### 2.2 数据计算

> **针对于某种逻辑结构，结合实际需求，定义基本运算。**

<aside> 💡 **创销增删改查。**

</aside>

### 2.3 物理结构(存储结构)

### 2.30 导学思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/7.jpg" ></img>

<aside> 💡 **顺序存储、链式存储、索引存储、散列存储**

</aside>

**索引存储：在存储元素信息的同时，建立附加索引表。索引表中的每项成为索引项，索引项的一般形式是(关键字，地址)。**

**散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。**

**关键字：用来区分不同数据项。**

<img src="https://yancey597.github.io/posts/b06cc6ec/8.jpg" ></img>

**顺序存储和非顺序存储**

<img src="https://yancey597.github.io/posts/b06cc6ec/9.jpg" ></img>

<aside> 💡 **定义：逻辑结构、运算 实现：存储结构**

</aside>

### 2.4 数据类型、抽象数据类型

<aside> 💡 **数据类型是一个值的集合和定义在此集合上的一组操作的总称。**

</aside>

**原子类型：其值不可再分的数据类型。如基本数据类型。**

**结构类型：其值可以再分解为若干(成分)的数据类型。如结构体。**

<aside> 💡 **抽象数据类型：是抽象数据组织及与之相关的操作。**

</aside>

**抽象数据类型的主要作用是数据封装和信息隐藏，让实现与使用相分离。数据及其相关操作的结合称为数据封装。对象可以对其他对象隐藏某些操作细节，从而使这些操作不会受到其他对象的影响，这就是信息隐藏。**

<img src="https://yancey597.github.io/posts/b06cc6ec/10.jpg" ></img>

**定义一个ADT，就是定义一个数据结构。**

**确定ADT的存储结构才能实现这种数据结构。**

> ADT就是用人能理解的话规定出某一问题求解所需要的数据(来自基本数据类型复合)，抽象出对应的操作方法，而不在意计算机中是如何实现这个过程的

### 2.5 思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/11.jpg" ></img>

## 3. 算法的基本概念

### 3.0 导学思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/12.jpg" ></img>

### 3.1 什么是算法

<aside> 💡 **算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作**

</aside>

**程序 = 数据结构 + 算法**

**数据结构：用数据描述现实世界并正确的传入计算机。**

**算法：如何高效的处理这些数据，解决实际问题。**

**求解问题的步骤。**

<img src="https://yancey597.github.io/posts/b06cc6ec/13.jpg" ></img>

> 不要把算法想的如此高深，给他一个宏观的概念。

### 3.2 算法的特性

<aside> 💡 **有穷性、确定性、可行性、输入、输出**

</aside>

**确定性：相同的输入输出都会有相同的结果。**

<img src="https://yancey597.github.io/posts/b06cc6ec/14.jpg" ></img>

> **对于最简单的排序算法，可能存在排序数据项相同的情况，但每次执行的结果应该一样，如同为49岁的两位大佬在算法执行后出现的位置应该是相同的。**

**可行性：算法描述的操作可以通过有限次的基本运算实现。**

> **不能实现不叫算法。**

### 3.3 好的算法的特征

<aside> 💡 **正确性、可读性、健壮性、高效率与低存储要求**

</aside>

> **解释下健壮性，对于使用者输入的一些非法值应该能做出对应的反应，而不是输出随机结果。**

### 3.4 思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/15.jpg" ></img>

## 4. 时间复杂度(T(n))

> **如何评估算法的时间开销？**

### 4.1 评估时间开销

<img src="https://yancey597.github.io/posts/b06cc6ec/16.jpg" ></img>

**不能通过事后统计的方法评估，受客观条件的影响。**

```java
public void loveyou(int n){
	int i = 1;
	while (i <= n) {//只关心执行次数最多的代码：n+1
		System.out.println("I Love more than" + (i++));//n
	}
}
T(3000) = 1 + 3001 + 2 * 3000 +1;
T(n) = 3n + 3;
```

**只考虑阶数高的部分，常数项系数也可以忽略。**

T(n) = O(n);

**加法法则：**多项相加只保留最高阶项，且系数变为1。

**乘法法则：**多项相乘都保留。

### 4.2 **时间复杂度的排序**

$O(1) < O(log_2n) < O(n) <O(nlog_2n)<O(n^2) < O(n^3)<O(2^n)<O(n!)<O(n^n)$

<aside> 💡 **常 对 幂 指 阶 $O(1)<<O(log_2n)<<O(n)<<O(2^n)<<O(n!)$**

</aside>

<img src="https://yancey597.github.io/posts/b06cc6ec/17.jpg" ></img>

### 4.3 时间复杂度的结论

<aside> 💡 **结论1：顺序执行的代码只影响常数项，可以直接忽略。 结论2：只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可 结论3：如果有多层嵌套循环，只需关注最深层循环循环了几次**

</aside>

### 4.4 最好、最坏、平均时间复杂度

```java
public void sort(int[] array, int n){
	for (int i = 0; i < array.length; i++){
		if (array[i] == n) {
			break;
		}
	}
}
```

> **上述代码的时间复杂度取决于数组元素的顺序。**

<img src="https://yancey597.github.io/posts/b06cc6ec/19.jpg" ></img>

### 4.5 思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/18.jpg" >

## 5.空间复杂度(S(n))

> **空间开销（内存开销）与问题规模 n 之间的关系**

### 5.1 普通程序的空间复杂度

```java
public void love(int n){
	int i = 1;
	while (i <= n) {
		i++;
		System.out.println("I Love you");
	}
	
}
```

<img src="https://yancey597.github.io/posts/b06cc6ec/21.jpg" ></img>

**无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为 S(n) = O(1)，注：S 表示 “Space”**

**算法原地工作——算法所需内存空间为常量**

**只需关注存储空间大小与问题规模相关的变量**

### 5.2 递归调用的空间复杂度

<img src="https://yancey597.github.io/posts/b06cc6ec/20.jpg" ></img>

**普通的递归调用是S(n) = O(n)**

**空间复杂度 = 递归调用的深度**

<img src="https://yancey597.github.io/posts/b06cc6ec/22.jpg" ></img>

### 5.3 思维导图

<img src="https://yancey597.github.io/posts/b06cc6ec/23.jpg" ></img>



---
**願愛無憂**

**Yancey**

